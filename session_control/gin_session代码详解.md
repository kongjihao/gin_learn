## 问题

> 我这个项目中为什么叫做创建了个Cookie 型 Session 存储？ 帮我详细解释下 go 中session使用的方式，以及我的session最后全部数据都存储到了store变量内存中了吗

## 详解

这是一个非常深刻且直击核心的问题！搞清楚这一点，你就理解了 Web 开发中“状态管理”的本质。

直接回答你的核心疑问：

为什么叫 Cookie 型 Session？ 因为你的 Session 数据本身（比如 user_id: 1001）是经过加密和编码后，直接存储在用户的浏览器 Cookie 里的，而不是存在你的服务器上。

全部数据都存储到 store 变量内存中了吗？ 没有！完全没有！ 你的服务器内存（store 变量）里只存了那两把“钥匙”（密钥），用来给数据打包和解包。真正的用户数据随着 HTTP 请求在网络上飞来飞去。

下面我为你详细拆解 Go 中 Session 的这两种模式，配合图解让你一目了然。

一、 核心揭秘：你的 NewCookieStore 到底做了什么？
你使用的 sessions.NewCookieStore 是一种 客户端存储（Client-side Storage） 模式。

1. 数据存在哪？

- 位置： 用户的浏览器里。

- 形式： 一串加密过的乱码字符串，放在 HTTP Header 的 Cookie 字段里。

- 流程：

  - 存： 服务器把 user_id=1001 用你的密钥加密 -> 生成一串乱码 -> 塞给浏览器说“拿着这个”。

  - 取： 浏览器下次访问带上这串乱码 -> 服务器用密钥解密 -> 拿到 user_id=1001。

1. store 变量在内存里存了什么？

- 它不存储任何用户的 Session 数据。 它在内存里只存了你初始化时传入的那两个配置：

  - 签名密钥 (your-secret-key-1)：用来防止用户篡改数据。（完整性 + 真实性）

  - 加密密钥 (your-encryption-key)：用来防止用户看懂数据。(保密性)

比喻： 你的服务器就像一个 “护照签发局”。

- store 变量就是印章和防伪墨水。

- Session 数据就是护照。

- 护照（Session）是发给游客（浏览器）带走的，签发局（服务器）自己不留底。下次游客带着护照来，你用印章（密钥）核对一下是不是真的，就能知道他是谁了。

二、 Go 中 Session 的两种主要使用方式
为了让你更清楚，我们需要对比一下 客户端存储（你现在的做法） 和 服务端存储（通常的“传统”做法）。

方式 1：Cookie Store (客户端存储) —— 你现在的代码
这就是 gorilla/sessions 的 NewCookieStore。

原理： 把数据塞进 Cookie。

优点：

- 省服务器内存： 有100万个用户在线，服务器内存占用也是 0，因为数据都在用户手机里。

- 分布式友好： 你部署10台服务器，用户请求打到哪台都能解密（只要密钥一样），不需要额外的数据库共享数据。

缺点：

- 容量限制： 浏览器限制 Cookie 不能超过 4KB。你不能往 Session 里存太大的数据（比如一篇博客文章）。

- 安全性风险： 虽然加密了，但数据毕竟在用户手上。如果密钥泄露，所有数据都能被破解。

<br>

方式 2：Server-side Store (服务端存储) —— 比如 Redis/MySQL
这是更适合大型系统的做法。在 Go 中通常使用 gin-contrib/sessions 配合 Redis。

原理：

- 服务器生成一个随机的 Session ID (比如 sess_abc123)。

- 把 user_id=1001 存到服务器的 Redis 或 内存 里，Key 就是 sess_abc123。

- 只把这个 Session ID 给浏览器（放在 Cookie 里）。

数据流向：

- 浏览器请求带上 ID (sess_abc123) -> 服务器拿 ID 去 Redis 查 -> 找到 user_id=1001。

优点：

- 安全： 用户只拿到了一个没有意义的 ID，真实数据在服务器保险柜里。

- 容量大： 你想存多少存多少，只受服务器硬盘/内存限制。

- 可控： 服务器可以强制踢人下线（直接在 Redis 删掉那个 ID 即可）。你现在的 Cookie Store 模式很难强制踢人（除非换密钥）。

<br>

三、 为什么你在这个项目选 Cookie Store？
对于初学者或者小型项目，NewCookieStore 是完美的选择：

- 零依赖： 不需要安装 Redis，不需要配置 MySQL，代码跑起来就能用。

- 简单： 逻辑闭环，不需要处理连接池、数据库断连等复杂问题。

四、 总结：你的代码究竟发生了什么？
当你执行 session.Save(c.Request, c.Writer) 时，底层发生了这些事：

- Go 拿出你设置的 map (例如 {"user_id": 1001})。

- Go 使用 gob 序列化库把这个 map 变成二进制。

- Go 使用 AES 算法（你的加密密钥）把二进制变成密文。

- Go 使用 HMAC 算法（你的签名密钥）给密文加个签名（防篡改）。

- Go 把这一长串东西拼接成字符串，通过 HTTP 响应头 Set-Cookie 发给浏览器。

- 内存清理： 请求结束，Go 函数栈销毁，这次处理的数据在服务器内存中就消失了。

所以，放心吧，你的服务器内存不会因为用户增多而爆炸。但要注意，别往 Session 里存太大的图片或长文本，否则会撑爆浏览器的 Cookie 限制（4KB）。
